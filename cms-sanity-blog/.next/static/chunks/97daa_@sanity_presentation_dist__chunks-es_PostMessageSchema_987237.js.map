{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"PostMessageSchema.js","sources":["file://C%3A/Users/fanta/Desktop/blog/cms-sanity-blog/node_modules/.pnpm/%40sanity%2Bpresentation%401.19.8_%40emotion%2Bis-prop-valid%401.2.2_%40sanity%2Bcolor%403.0.6_debug%404.4.0_reac_epti5vobal4q5xpl7pmbcf6wnm/node_modules/%40sanity/presentation/src/overlays/schema/helpers.ts","file://C%3A/Users/fanta/Desktop/blog/cms-sanity-blog/node_modules/.pnpm/%40sanity%2Bpresentation%401.19.8_%40emotion%2Bis-prop-valid%401.2.2_%40sanity%2Bcolor%403.0.6_debug%404.4.0_reac_epti5vobal4q5xpl7pmbcf6wnm/node_modules/%40sanity/presentation/src/overlays/schema/SchemaIcon.tsx","file://C%3A/Users/fanta/Desktop/blog/cms-sanity-blog/node_modules/.pnpm/%40sanity%2Bpresentation%401.19.8_%40emotion%2Bis-prop-valid%401.2.2_%40sanity%2Bcolor%403.0.6_debug%404.4.0_reac_epti5vobal4q5xpl7pmbcf6wnm/node_modules/%40sanity/presentation/src/overlays/schema/extract.ts","file://C%3A/Users/fanta/Desktop/blog/cms-sanity-blog/node_modules/.pnpm/%40sanity%2Bpresentation%401.19.8_%40emotion%2Bis-prop-valid%401.2.2_%40sanity%2Bcolor%403.0.6_debug%404.4.0_reac_epti5vobal4q5xpl7pmbcf6wnm/node_modules/%40sanity/presentation/src/overlays/schema/PostMessageSchema.tsx"],"sourcesContent":["import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type SchemaType as SanitySchemaType,\n  type Schema as SchemaDef,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {type SchemaType} from 'groq-js'\n\nexport function isFieldRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\nexport function isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nexport function isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nexport function isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\n// @todo\nexport function isCrossDatasetReferenceType(typeDef: SanitySchemaType): boolean {\n  return isType(typeDef, 'crossDatasetReference')\n}\nexport function isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nexport function isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nexport function lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n// Traverse the type tree and gather all the fields\nexport function gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Sorts the types by their dependencies by using a topological sort depth-first algorithm.\nexport function sortByDependencies(compiledSchema: SchemaDef): string[] {\n  const seen = new Set<SanitySchemaType>()\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n          }\n        }\n        walkDependencies(field.type, dependencies)\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies)\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies)\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (!typeNames.includes(type.name)) {\n      typeNames.unshift(type.name)\n    }\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return typeNames\n}\n","import {type SchemaType as SanitySchemaType} from '@sanity/types'\nimport {ThemeProvider, type ThemeContextValue} from '@sanity/ui'\nimport {createElement, type FunctionComponent} from 'react'\nimport {ServerStyleSheet, StyleSheetManager} from 'styled-components'\n\nexport const SchemaIcon: FunctionComponent<{\n  schemaType: SanitySchemaType\n  theme: ThemeContextValue\n}> = function SchemaIcon({schemaType, theme: themeContext}) {\n  const {theme, scheme, tone} = themeContext\n  const sheet = new ServerStyleSheet()\n\n  return schemaType.icon ? (\n    <StyleSheetManager sheet={sheet.instance}>\n      <ThemeProvider theme={theme} scheme={scheme} tone={tone}>\n        {createElement(schemaType.icon)}\n      </ThemeProvider>\n    </StyleSheetManager>\n  ) : null\n}\n","import type {\n  SchemaArrayNode,\n  SchemaBooleanNode,\n  SchemaInlineNode,\n  SchemaNode,\n  SchemaNullNode,\n  SchemaNumberNode,\n  SchemaObjectField,\n  SchemaObjectNode,\n  SchemaStringNode,\n  SchemaType,\n  SchemaUnionNode,\n  SchemaUnionNodeOptions,\n  SchemaUnionOption,\n  SchemaUnknownNode,\n} from '@repo/visual-editing-helpers'\nimport type {InsertMenuOptions} from '@sanity/insert-menu'\nimport type {\n  ArraySchemaType,\n  NumberSchemaType,\n  ObjectSchemaType,\n  ReferenceSchemaType,\n  SchemaType as SanitySchemaType,\n  StringSchemaType,\n} from '@sanity/types'\nimport type {ThemeContextValue} from '@sanity/ui'\nimport {createElement} from 'react'\nimport {renderToString} from 'react-dom/server'\nimport type {Workspace} from 'sanity'\nimport {\n  gatherFields,\n  isArrayType,\n  isCrossDatasetReferenceType,\n  isFieldRequired,\n  isNumberType,\n  isObjectType,\n  isReferenceType,\n  isStringType,\n  lastType,\n  sortByDependencies,\n} from './helpers'\nimport {SchemaIcon} from './SchemaIcon'\n\nconst documentDefaultFields = (typeName: string): Record<string, SchemaObjectField> => ({\n  _id: {\n    type: 'objectField',\n    name: '_id',\n    value: {\n      type: 'string',\n    },\n  },\n  _type: {\n    type: 'objectField',\n    name: '_type',\n    value: {\n      type: 'string',\n      value: typeName,\n    },\n  },\n  _createdAt: {\n    type: 'objectField',\n    name: '_createdAt',\n    value: {\n      type: 'string',\n    },\n  },\n  _updatedAt: {\n    type: 'objectField',\n    name: '_updatedAt',\n    value: {\n      type: 'string',\n    },\n  },\n  _rev: {\n    type: 'objectField',\n    name: '_rev',\n    value: {\n      type: 'string',\n    },\n  },\n})\n\nfunction createStringNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): SchemaStringNode | SchemaUnionNode<SchemaStringNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): SchemaNumberNode | SchemaUnionNode<SchemaNumberNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\nfunction createReferenceNode(name: string, inArray: boolean = false): SchemaObjectNode {\n  const fields: Record<string, SchemaObjectField> = {\n    _ref: {\n      type: 'objectField',\n      name: '_ref',\n      value: {\n        type: 'string',\n      },\n    },\n    _type: {\n      type: 'objectField',\n      name: '_type',\n      value: {\n        type: 'string',\n        value: 'reference',\n      },\n    },\n    _weak: {\n      type: 'objectField',\n      name: '_weak',\n      value: {\n        type: 'boolean',\n      },\n      optional: true,\n    },\n  }\n\n  if (inArray) {\n    fields['_key'] = {\n      type: 'objectField',\n      name: '_key',\n      value: {\n        type: 'string',\n      },\n    } satisfies SchemaObjectField\n  }\n\n  return {\n    type: 'object',\n    fields,\n    dereferencesTo: name,\n  } satisfies SchemaObjectNode\n}\n\nfunction createReferenceNodeDefintion(\n  reference: ReferenceSchemaType,\n): SchemaObjectNode | SchemaUnionNode<SchemaObjectNode> {\n  const references = gatherReferenceNames(reference)\n  if (references.length === 1) {\n    return createReferenceNode(references[0])\n  }\n\n  return {\n    type: 'union',\n    of: references.map((name) => ({\n      type: 'unionOption',\n      name,\n      value: createReferenceNode(name),\n    })),\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set([...allReferences.map((ref) => ref.name)])]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\nconst typesMap = new Map<string, Omit<SchemaStringNode, 'name'> | Omit<SchemaBooleanNode, 'name'>>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport function extractSchema(workspace: Workspace, theme: ThemeContextValue): SchemaType[] {\n  const inlineFields = new Set<SanitySchemaType>()\n  const {schema: schemaDef, basePath} = workspace\n\n  const sortedSchemaTypeNames = sortByDependencies(schemaDef)\n  return sortedSchemaTypeNames\n    .map((typeName) => {\n      const schemaType = schemaDef.get(typeName)\n      if (schemaType === undefined) {\n        return\n      }\n      const base = convertBaseType(schemaType)\n\n      if (base === null) {\n        return\n      }\n\n      if (base.type === 'type') {\n        inlineFields.add(schemaType)\n      }\n\n      return base\n    })\n    .filter((type: SchemaType | undefined): type is SchemaType => type !== undefined)\n\n  function extractIcon(schemaType: SanitySchemaType): string | undefined {\n    if (!schemaType.icon) return undefined\n    return renderToString(createElement(SchemaIcon, {schemaType, theme}))\n  }\n\n  function convertBaseType(schemaType: SanitySchemaType): SchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document') {\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        type: 'document',\n        name: schemaType.name,\n        title: typeof schemaType.title === 'string' ? schemaType.title : undefined,\n        icon: extractIcon(schemaType),\n        fields: {\n          ...documentDefaultFields(schemaType.name),\n          ...object.fields,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n\n    if (value.type === 'object') {\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value: {\n          type: 'object',\n          fields: {\n            _type: {\n              type: 'objectField',\n              name: '_type',\n              value: {\n                type: 'string',\n                value: schemaType.name,\n              },\n            },\n            ...value.fields,\n          },\n        },\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      title: typeof schemaType.title === 'string' ? schemaType.title : undefined,\n      type: 'type',\n      value,\n    }\n  }\n\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): SchemaObjectNode | SchemaUnknownNode {\n    const fields: Record<string, SchemaObjectField> = {}\n\n    for (const field of gatherFields(schemaType)) {\n      const value = convertSchemaType(field.type)\n      if (value === null) {\n        continue\n      }\n\n      fields[field.name] = {\n        type: 'objectField',\n        name: field.name,\n        title: typeof field.type.title === 'string' ? field.type.title : undefined,\n        value,\n        optional: isFieldRequired(field) === false,\n      }\n    }\n\n    return {\n      type: 'object',\n      fields,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): SchemaNode {\n    if (lastType(schemaType)?.name === 'document') {\n      return createReferenceNode(schemaType.name)\n    }\n\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies SchemaInlineNode\n    }\n\n    if (schemaType.type?.type?.name === 'object') {\n      return {type: 'inline', name: schemaType.type.name} satisfies SchemaInlineNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberNodeDefintion(schemaType)\n    }\n\n    const mapped = typesMap.get(schemaType.type?.name || '')\n    if (mapped) {\n      return mapped\n    }\n\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies SchemaUnknownNode // we don't support cross-dataset references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n\n  function createUnionNodeOptions(\n    schemaType: ArraySchemaType,\n    of: SchemaUnionOption<SchemaNode>[],\n  ): SchemaUnionNodeOptions | undefined {\n    const {options} = schemaType\n    if (!options) return undefined\n    const opts = {\n      ...options,\n    }\n    if (options.insertMenu) {\n      opts.insertMenu = {\n        ...options.insertMenu,\n        views: (options.insertMenu as InsertMenuOptions).views?.map((view) =>\n          view.name === 'grid'\n            ? {\n                name: 'grid',\n                previewImageUrls: view.previewImageUrl\n                  ? of.reduce(\n                      (acc, {name}) => {\n                        const url = view.previewImageUrl?.(name)\n                        if (!url) return acc\n                        // If the URL is relative, make it absolute\n                        try {\n                          new URL(url)\n                          acc[name] = url\n                        } catch {\n                          acc[name] = new URL(\n                            url,\n                            `${window.location.origin}${basePath ? `${basePath}/` : ''}`,\n                          ).toString()\n                        }\n                        return acc\n                      },\n                      {} as Record<string, string | undefined>,\n                    )\n                  : undefined,\n              }\n            : view,\n        ),\n      }\n    }\n    return opts\n  }\n\n  function createArray(\n    arraySchemaType: ArraySchemaType,\n  ): SchemaArrayNode | SchemaUnionNode | SchemaNullNode {\n    const of: SchemaUnionOption[] = []\n    for (const item of arraySchemaType.of) {\n      let field = convertSchemaType(item)\n      const option = {\n        type: 'unionOption',\n        icon: extractIcon(item),\n        name: item.name,\n        title: typeof item.title === 'string' ? item.title : undefined,\n        value: field,\n      } satisfies SchemaUnionOption\n      if (field.type === 'inline') {\n        field = {\n          type: 'object',\n          fields: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies SchemaObjectNode\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          fields: {\n            _key: createKeyField(),\n          },\n        }\n      }\n      option.value = field\n      of.push(option)\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    if (of.length > 1) {\n      return {\n        type: 'union',\n        of,\n        options: createUnionNodeOptions(arraySchemaType, of),\n      }\n    }\n\n    const {name, title, value} = of[0]\n    return {\n      type: 'array',\n      of: {\n        type: 'arrayItem',\n        name,\n        title: typeof title === 'string' ? title : undefined,\n        value,\n      },\n    }\n  }\n}\n\nfunction createKeyField(): SchemaObjectField<SchemaStringNode> {\n  return {\n    type: 'objectField',\n    name: '_key',\n    value: {\n      type: 'string',\n    },\n  }\n}\n","import type {UnresolvedPath} from '@repo/visual-editing-helpers'\nimport type {ClientPerspective} from '@sanity/client'\nimport {useRootTheme} from '@sanity/ui'\nimport {memo, useEffect} from 'react'\nimport {API_VERSION} from '../../constants'\nimport {useClient, useWorkspace} from '../../internals'\nimport type {VisualEditingConnection} from '../../types'\nimport {extractSchema} from './extract'\n\nexport interface PostMessageSchemaProps {\n  comlink: VisualEditingConnection\n  perspective: ClientPerspective\n}\n\nfunction getDocumentPathArray(paths: UnresolvedPath[]) {\n  const documentPathMap = paths.reduce(\n    (acc, {id, path}) => {\n      if (acc[id]) {\n        acc[id].add(path)\n      } else {\n        acc[id] = new Set<string>([path])\n      }\n      return acc\n    },\n    {} as Record<string, Set<string>>,\n  )\n\n  return Object.entries(documentPathMap)\n}\n\n/**\n * Experimental approach for sending a representation of the workspace schema\n * over postMessage so it can be used to enrich the Visual Editing experience\n */\nfunction PostMessageSchema(props: PostMessageSchemaProps): JSX.Element | null {\n  const {comlink, perspective} = props\n\n  const workspace = useWorkspace()\n  const theme = useRootTheme()\n\n  // Send a representation of the schema to the visual editing context\n  useEffect(() => {\n    const schema = extractSchema(workspace, theme)\n    /**\n     * @deprecated switch to explict schema fetching (using\n     * 'visual-editing/schema') at next major\n     */\n    comlink.post('presentation/schema', {schema})\n\n    return comlink.on('visual-editing/schema', () => ({schema}))\n  }, [comlink, theme, workspace])\n\n  const client = useClient({apiVersion: API_VERSION})\n\n  // Resolve union types from an array of unresolved paths\n  useEffect(() => {\n    return comlink.on('visual-editing/schema-union-types', async (data) => {\n      const documentPathArray = getDocumentPathArray(data.paths)\n      const unionTypes = await Promise.all(\n        documentPathArray.map(async ([id, paths]) => {\n          const arr = Array.from(paths)\n          const projection = arr.map((path, i) => `\"${i}\": ${path}[0]._type`).join(',')\n          const query = `*[_id == $id][0]{${projection}}`\n          const result = await client.fetch(query, {id}, {perspective, tag: 'presentation-schema'})\n          const mapped = arr.map((path, i) => ({path: path, type: result[i]}))\n          return {id, paths: mapped}\n        }),\n      )\n\n      const newState = new Map()\n      unionTypes.forEach((action) => {\n        newState.set(action.id, new Map(action.paths.map(({path, type}) => [path, type])))\n      })\n      return {types: newState}\n    })\n  }, [comlink, client, perspective])\n\n  return null\n}\n\nexport default memo(PostMessageSchema)\n"],"names":["isFieldRequired","field","validation","type","rules","Array","isArray","rule","required","proxy","Proxy","get","target","methodName","_required","isType","typeDef","typeName","name","isObjectType","jsonType","isArrayType","isReferenceType","isCrossDatasetReferenceType","isStringType","isNumberType","lastType","gatherFields","concat","fields","sortByDependencies","compiledSchema","seen","Set","walkDependencies","schemaType","dependencies","has","add","last","schemaTypeName","to","forEach","ref","item","of","dependencyMap","Map","getTypeNames","undefined","set","clear","typeNames","currentlyVisiting","visited","visit","deps","dep","delete","includes","unshift","SchemaIcon","t0","$","_c","theme","themeContext","scheme","tone","t1","Symbol","for","ServerStyleSheet","sheet","t2","icon","instance","createElement","documentDefaultFields","_id","value","_type","_createdAt","_updatedAt","_rev","createStringNodeDefintion","stringSchemaType","listOptions","options","list","map","v","createNumberNodeDefintion","numberSchemaType","createReferenceNode","inArray","_ref","_weak","optional","dereferencesTo","createReferenceNodeDefintion","reference","references","gatherReferenceNames","length","allReferences","gatherReferenceTypes","refTo","typesMap","extractSchema","workspace","inlineFields","schema","schemaDef","basePath","base","convertBaseType","filter","extractIcon","renderToString","object","createObject","title","convertSchemaType","mapped","createArray","Error","createUnionNodeOptions","opts","insertMenu","views","view","previewImageUrls","previewImageUrl","reduce","acc","url","URL","window","location","origin","toString","arraySchemaType","option","_key","createKeyField","rest","push","getDocumentPathArray","paths","documentPathMap","id","path","Object","entries","PostMessageSchema","props","comlink","perspective","useWorkspace","useRootTheme","post","on","useEffect","apiVersion","API_VERSION","client","useClient","t3","t4","data","documentPathArray","unionTypes","Promise","all","t5","arr","from","query","_temp","join","result","fetch","tag","path_0","i_0","i","newState","action","_temp2","types","path_1","memo"],"mappings":"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","ignoreList":[0,1,2,3]}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}